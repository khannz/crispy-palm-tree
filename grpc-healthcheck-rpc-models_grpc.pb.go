// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package portadapter

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// HCGetClient is the client API for HCGet service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HCGetClient interface {
	HCGetPbService(ctx context.Context, in *PbService, opts ...grpc.CallOption) (*PbService, error)
	HCGetPbServiceS(ctx context.Context, in *EmptyPbService, opts ...grpc.CallOption) (*PbServices, error)
}

type hCGetClient struct {
	cc grpc.ClientConnInterface
}

func NewHCGetClient(cc grpc.ClientConnInterface) HCGetClient {
	return &hCGetClient{cc}
}

func (c *hCGetClient) HCGetPbService(ctx context.Context, in *PbService, opts ...grpc.CallOption) (*PbService, error) {
	out := new(PbService)
	err := c.cc.Invoke(ctx, "/transport.HCGet/HCGetPbService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hCGetClient) HCGetPbServiceS(ctx context.Context, in *EmptyPbService, opts ...grpc.CallOption) (*PbServices, error) {
	out := new(PbServices)
	err := c.cc.Invoke(ctx, "/transport.HCGet/HCGetPbServiceS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HCGetServer is the server API for HCGet service.
// All implementations must embed UnimplementedHCGetServer
// for forward compatibility
type HCGetServer interface {
	HCGetPbService(context.Context, *PbService) (*PbService, error)
	HCGetPbServiceS(context.Context, *EmptyPbService) (*PbServices, error)
	mustEmbedUnimplementedHCGetServer()
}

// UnimplementedHCGetServer must be embedded to have forward compatible implementations.
type UnimplementedHCGetServer struct {
}

func (UnimplementedHCGetServer) HCGetPbService(context.Context, *PbService) (*PbService, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HCGetPbService not implemented")
}
func (UnimplementedHCGetServer) HCGetPbServiceS(context.Context, *EmptyPbService) (*PbServices, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HCGetPbServiceS not implemented")
}
func (UnimplementedHCGetServer) mustEmbedUnimplementedHCGetServer() {}

// UnsafeHCGetServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HCGetServer will
// result in compilation errors.
type UnsafeHCGetServer interface {
	mustEmbedUnimplementedHCGetServer()
}

func RegisterHCGetServer(s *grpc.Server, srv HCGetServer) {
	s.RegisterService(&_HCGet_serviceDesc, srv)
}

func _HCGet_HCGetPbService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PbService)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HCGetServer).HCGetPbService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/transport.HCGet/HCGetPbService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HCGetServer).HCGetPbService(ctx, req.(*PbService))
	}
	return interceptor(ctx, in, info, handler)
}

func _HCGet_HCGetPbServiceS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyPbService)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HCGetServer).HCGetPbServiceS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/transport.HCGet/HCGetPbServiceS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HCGetServer).HCGetPbServiceS(ctx, req.(*EmptyPbService))
	}
	return interceptor(ctx, in, info, handler)
}

var _HCGet_serviceDesc = grpc.ServiceDesc{
	ServiceName: "transport.HCGet",
	HandlerType: (*HCGetServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HCGetPbService",
			Handler:    _HCGet_HCGetPbService_Handler,
		},
		{
			MethodName: "HCGetPbServiceS",
			Handler:    _HCGet_HCGetPbServiceS_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc-healthcheck-rpc-models.proto",
}

// HCNewClient is the client API for HCNew service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HCNewClient interface {
	HCNewPbService(ctx context.Context, in *PbService, opts ...grpc.CallOption) (*EmptyPbService, error)
}

type hCNewClient struct {
	cc grpc.ClientConnInterface
}

func NewHCNewClient(cc grpc.ClientConnInterface) HCNewClient {
	return &hCNewClient{cc}
}

func (c *hCNewClient) HCNewPbService(ctx context.Context, in *PbService, opts ...grpc.CallOption) (*EmptyPbService, error) {
	out := new(EmptyPbService)
	err := c.cc.Invoke(ctx, "/transport.HCNew/HCNewPbService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HCNewServer is the server API for HCNew service.
// All implementations must embed UnimplementedHCNewServer
// for forward compatibility
type HCNewServer interface {
	HCNewPbService(context.Context, *PbService) (*EmptyPbService, error)
	mustEmbedUnimplementedHCNewServer()
}

// UnimplementedHCNewServer must be embedded to have forward compatible implementations.
type UnimplementedHCNewServer struct {
}

func (UnimplementedHCNewServer) HCNewPbService(context.Context, *PbService) (*EmptyPbService, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HCNewPbService not implemented")
}
func (UnimplementedHCNewServer) mustEmbedUnimplementedHCNewServer() {}

// UnsafeHCNewServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HCNewServer will
// result in compilation errors.
type UnsafeHCNewServer interface {
	mustEmbedUnimplementedHCNewServer()
}

func RegisterHCNewServer(s *grpc.Server, srv HCNewServer) {
	s.RegisterService(&_HCNew_serviceDesc, srv)
}

func _HCNew_HCNewPbService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PbService)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HCNewServer).HCNewPbService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/transport.HCNew/HCNewPbService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HCNewServer).HCNewPbService(ctx, req.(*PbService))
	}
	return interceptor(ctx, in, info, handler)
}

var _HCNew_serviceDesc = grpc.ServiceDesc{
	ServiceName: "transport.HCNew",
	HandlerType: (*HCNewServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HCNewPbService",
			Handler:    _HCNew_HCNewPbService_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc-healthcheck-rpc-models.proto",
}

// HCUpdateClient is the client API for HCUpdate service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HCUpdateClient interface {
	HCUpdatePbService(ctx context.Context, in *PbService, opts ...grpc.CallOption) (*PbService, error)
	HCRemovePbService(ctx context.Context, in *PbService, opts ...grpc.CallOption) (*EmptyPbService, error)
}

type hCUpdateClient struct {
	cc grpc.ClientConnInterface
}

func NewHCUpdateClient(cc grpc.ClientConnInterface) HCUpdateClient {
	return &hCUpdateClient{cc}
}

func (c *hCUpdateClient) HCUpdatePbService(ctx context.Context, in *PbService, opts ...grpc.CallOption) (*PbService, error) {
	out := new(PbService)
	err := c.cc.Invoke(ctx, "/transport.HCUpdate/HCUpdatePbService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hCUpdateClient) HCRemovePbService(ctx context.Context, in *PbService, opts ...grpc.CallOption) (*EmptyPbService, error) {
	out := new(EmptyPbService)
	err := c.cc.Invoke(ctx, "/transport.HCUpdate/HCRemovePbService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HCUpdateServer is the server API for HCUpdate service.
// All implementations must embed UnimplementedHCUpdateServer
// for forward compatibility
type HCUpdateServer interface {
	HCUpdatePbService(context.Context, *PbService) (*PbService, error)
	HCRemovePbService(context.Context, *PbService) (*EmptyPbService, error)
	mustEmbedUnimplementedHCUpdateServer()
}

// UnimplementedHCUpdateServer must be embedded to have forward compatible implementations.
type UnimplementedHCUpdateServer struct {
}

func (UnimplementedHCUpdateServer) HCUpdatePbService(context.Context, *PbService) (*PbService, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HCUpdatePbService not implemented")
}
func (UnimplementedHCUpdateServer) HCRemovePbService(context.Context, *PbService) (*EmptyPbService, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HCRemovePbService not implemented")
}
func (UnimplementedHCUpdateServer) mustEmbedUnimplementedHCUpdateServer() {}

// UnsafeHCUpdateServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HCUpdateServer will
// result in compilation errors.
type UnsafeHCUpdateServer interface {
	mustEmbedUnimplementedHCUpdateServer()
}

func RegisterHCUpdateServer(s *grpc.Server, srv HCUpdateServer) {
	s.RegisterService(&_HCUpdate_serviceDesc, srv)
}

func _HCUpdate_HCUpdatePbService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PbService)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HCUpdateServer).HCUpdatePbService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/transport.HCUpdate/HCUpdatePbService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HCUpdateServer).HCUpdatePbService(ctx, req.(*PbService))
	}
	return interceptor(ctx, in, info, handler)
}

func _HCUpdate_HCRemovePbService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PbService)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HCUpdateServer).HCRemovePbService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/transport.HCUpdate/HCRemovePbService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HCUpdateServer).HCRemovePbService(ctx, req.(*PbService))
	}
	return interceptor(ctx, in, info, handler)
}

var _HCUpdate_serviceDesc = grpc.ServiceDesc{
	ServiceName: "transport.HCUpdate",
	HandlerType: (*HCUpdateServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HCUpdatePbService",
			Handler:    _HCUpdate_HCUpdatePbService_Handler,
		},
		{
			MethodName: "HCRemovePbService",
			Handler:    _HCUpdate_HCRemovePbService_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc-healthcheck-rpc-models.proto",
}
